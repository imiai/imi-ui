{"version":3,"file":"useResizeObserver.js","sources":["../../src/hooks/useResizeObserver.tsx"],"sourcesContent":["import {\n    useEffect,\n    useState,\n    useRef,\n    useMemo,\n    RefObject,\n    RefCallback,\n    useCallback,\n  } from \"react\";\n  \n  type SubscriberCleanup = () => void;\n  type SubscriberResponse = SubscriberCleanup | void;\n  \n  // This of course could've been more streamlined with internal state instead of\n  // refs, but then host hooks / components could not opt out of renders.\n  // This could've been exported to its own module, but the current build doesn't\n  // seem to work with module imports and I had no more time to spend on this...\n  function useResolvedElement<T extends HTMLElement>(\n    subscriber: (element: T) => SubscriberResponse,\n    refOrElement?: T | RefObject<T> | null\n  ): RefCallback<T> {\n    const callbackRefElement = useRef<T | null>(null);\n    const lastReportRef = useRef<{\n      reporter: () => void;\n      element: T | null;\n    } | null>(null);\n    const cleanupRef = useRef<SubscriberResponse | null>();\n  \n    const callSubscriber = useCallback(() => {\n      let element = null;\n      if (callbackRefElement.current) {\n        element = callbackRefElement.current;\n      } else if (refOrElement) {\n        if (refOrElement instanceof HTMLElement) {\n          element = refOrElement;\n        } else {\n          element = refOrElement.current;\n        }\n      }\n  \n      if (\n        lastReportRef.current &&\n        lastReportRef.current.element === element &&\n        lastReportRef.current.reporter === callSubscriber\n      ) {\n        return;\n      }\n  \n      if (cleanupRef.current) {\n        cleanupRef.current();\n        // Making sure the cleanup is not called accidentally multiple times.\n        cleanupRef.current = null;\n      }\n      lastReportRef.current = {\n        reporter: callSubscriber,\n        element,\n      };\n  \n      // Only calling the subscriber, if there's an actual element to report.\n      if (element) {\n        cleanupRef.current = subscriber(element);\n      }\n    }, [refOrElement, subscriber]);\n  \n    // On each render, we check whether a ref changed, or if we got a new raw\n    // element.\n    useEffect(() => {\n      // With this we're *technically* supporting cases where ref objects' current value changes, but only if there's a\n      // render accompanying that change as well.\n      // To guarantee we always have the right element, one must use the ref callback provided instead, but we support\n      // RefObjects to make the hook API more convenient in certain cases.\n      callSubscriber();\n    }, [callSubscriber]);\n  \n    return useCallback<RefCallback<T>>(\n      (element) => {\n        callbackRefElement.current = element;\n        callSubscriber();\n      },\n      [callSubscriber]\n    );\n  }\n  \n  type ObservedSize = {\n    width: number | undefined;\n    height: number | undefined;\n  };\n  \n  type ResizeHandler = (size: ObservedSize) => void;\n  \n  type HookResponse<T extends HTMLElement> = {\n    ref: RefCallback<T>;\n  } & ObservedSize;\n  \n  // Declaring my own type here instead of using the one provided by TS (available since 4.2.2), because this way I'm not\n  // forcing consumers to use a specific TS version.\n  type ResizeObserverBoxOptions =\n    | \"border-box\"\n    | \"content-box\"\n    | \"device-pixel-content-box\";\n  \n  declare global {\n    interface ResizeObserverEntry {\n      readonly devicePixelContentBoxSize: ReadonlyArray<ResizeObserverSize>;\n    }\n  }\n  \n  // We're only using the first element of the size sequences, until future versions of the spec solidify on how\n  // exactly it'll be used for fragments in multi-column scenarios:\n  // From the spec:\n  // > The box size properties are exposed as FrozenArray in order to support elements that have multiple fragments,\n  // > which occur in multi-column scenarios. However the current definitions of content rect and border box do not\n  // > mention how those boxes are affected by multi-column layout. In this spec, there will only be a single\n  // > ResizeObserverSize returned in the FrozenArray, which will correspond to the dimensions of the first column.\n  // > A future version of this spec will extend the returned FrozenArray to contain the per-fragment size information.\n  // (https://drafts.csswg.org/resize-observer/#resize-observer-entry-interface)\n  //\n  // Also, testing these new box options revealed that in both Chrome and FF everything is returned in the callback,\n  // regardless of the \"box\" option.\n  // The spec states the following on this:\n  // > This does not have any impact on which box dimensions are returned to the defined callback when the event\n  // > is fired, it solely defines which box the author wishes to observe layout changes on.\n  // (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n  // I'm not exactly clear on what this means, especially when you consider a later section stating the following:\n  // > This section is non-normative. An author may desire to observe more than one CSS box.\n  // > In this case, author will need to use multiple ResizeObservers.\n  // (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n  // Which is clearly not how current browser implementations behave, and seems to contradict the previous quote.\n  // For this reason I decided to only return the requested size,\n  // even though it seems we have access to results for all box types.\n  // This also means that we get to keep the current api, being able to return a simple { width, height } pair,\n  // regardless of box option.\n  const extractSize = (\n    entry: ResizeObserverEntry,\n    boxProp: \"borderBoxSize\" | \"contentBoxSize\" | \"devicePixelContentBoxSize\",\n    sizeType: keyof ResizeObserverSize\n  ): number | undefined => {\n    if (!entry[boxProp]) {\n      if (boxProp === \"contentBoxSize\") {\n        // The dimensions in `contentBoxSize` and `contentRect` are equivalent according to the spec.\n        // See the 6th step in the description for the RO algorithm:\n        // https://drafts.csswg.org/resize-observer/#create-and-populate-resizeobserverentry-h\n        // > Set this.contentRect to logical this.contentBoxSize given target and observedBox of \"content-box\".\n        // In real browser implementations of course these objects differ, but the width/height values should be equivalent.\n        return entry.contentRect[sizeType === \"inlineSize\" ? \"width\" : \"height\"];\n      }\n  \n      return undefined;\n    }\n  \n    // A couple bytes smaller than calling Array.isArray() and just as effective here.\n    return entry[boxProp][0]\n      ? entry[boxProp][0][sizeType]\n      : // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current\n        // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.\n        // @ts-ignore\n        entry[boxProp][sizeType];\n  };\n  \n  type RoundingFunction = (n: number) => number;\n  \n  function useResizeObserver<T extends HTMLElement>(\n    opts: {\n      ref?: RefObject<T> | T | null | undefined;\n      onResize?: ResizeHandler;\n      box?: ResizeObserverBoxOptions;\n      round?: RoundingFunction;\n    } = {}\n  ): HookResponse<T> {\n    // Saving the callback as a ref. With this, I don't need to put onResize in the\n    // effect dep array, and just passing in an anonymous function without memoising\n    // will not reinstantiate the hook's ResizeObserver.\n    const onResize = opts.onResize;\n    const onResizeRef = useRef<ResizeHandler | undefined>(undefined);\n    onResizeRef.current = onResize;\n    const round = opts.round || Math.round;\n  \n    // Using a single instance throughout the hook's lifetime\n    const resizeObserverRef = useRef<{\n      box?: ResizeObserverBoxOptions;\n      round?: RoundingFunction;\n      instance: ResizeObserver;\n    }>();\n  \n    const [size, setSize] = useState<{\n      width?: number;\n      height?: number;\n    }>({\n      width: undefined,\n      height: undefined,\n    });\n  \n    // In certain edge cases the RO might want to report a size change just after\n    // the component unmounted.\n    const didUnmount = useRef(false);\n    useEffect(() => {\n      return () => {\n        didUnmount.current = true;\n      };\n    }, []);\n  \n    // Using a ref to track the previous width / height to avoid unnecessary renders.\n    const previous: {\n      current: {\n        width?: number;\n        height?: number;\n      };\n    } = useRef({\n      width: undefined,\n      height: undefined,\n    });\n  \n    // This block is kinda like a useEffect, only it's called whenever a new\n    // element could be resolved based on the ref option. It also has a cleanup\n    // function.\n    const refCallback = useResolvedElement<T>(\n      useCallback(\n        (element) => {\n          // We only use a single Resize Observer instance, and we're instantiating it on demand, only once there's something to observe.\n          // This instance is also recreated when the `box` option changes, so that a new observation is fired if there was a previously observed element with a different box option.\n          if (\n            !resizeObserverRef.current ||\n            resizeObserverRef.current.box !== opts.box ||\n            resizeObserverRef.current.round !== round\n          ) {\n            resizeObserverRef.current = {\n              box: opts.box,\n              round,\n              instance: new ResizeObserver((entries) => {\n                const entry = entries[0];\n  \n                const boxProp =\n                  opts.box === \"border-box\"\n                    ? \"borderBoxSize\"\n                    : opts.box === \"device-pixel-content-box\"\n                    ? \"devicePixelContentBoxSize\"\n                    : \"contentBoxSize\";\n  \n                const reportedWidth = extractSize(entry, boxProp, \"inlineSize\");\n                const reportedHeight = extractSize(entry, boxProp, \"blockSize\");\n  \n                const newWidth = reportedWidth ? round(reportedWidth) : undefined;\n                const newHeight = reportedHeight\n                  ? round(reportedHeight)\n                  : undefined;\n  \n                if (\n                  previous.current.width !== newWidth ||\n                  previous.current.height !== newHeight\n                ) {\n                  const newSize = { width: newWidth, height: newHeight };\n                  previous.current.width = newWidth;\n                  previous.current.height = newHeight;\n                  if (onResizeRef.current) {\n                    onResizeRef.current(newSize);\n                  } else {\n                    if (!didUnmount.current) {\n                      setSize(newSize);\n                    }\n                  }\n                }\n              }),\n            };\n          }\n  \n          resizeObserverRef.current.instance.observe(element, { box: opts.box });\n  \n          return () => {\n            if (resizeObserverRef.current) {\n              resizeObserverRef.current.instance.unobserve(element);\n            }\n          };\n        },\n        [opts.box, round]\n      ),\n      opts.ref\n    );\n  \n    return useMemo(\n      () => ({\n        ref: refCallback,\n        width: size.width,\n        height: size.height,\n      }),\n      [refCallback, size ? size.width : null, size ? size.height : null]\n    );\n  }\n  \n  export default useResizeObserver;"],"names":[],"mappings":"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"}